# 객체지향 VS 절차지향



> 절차지향(Procedural Programming)이란?

- 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법입니다.
- 대표적인 절차지향 언어에는 C언어가 있습니다.
- 절차지향 프로그래밍은 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빨리 처리되어 시간적으로 유리합니다.

- 장점
  - 컴퓨터의 처리구조와 유사해 실행 속도가 빠릅니다.
- 단점
  - 유지보수가 어려움
  - 실행 순서가 정해져 있으므로 코드의 순서가 바뀌면 동일한 결과를 보장하기 어려움
  - 디버깅이 어려움



> 객체지향(Object Oriented Programming)이란?

- 실제 세계를 모델링하여 소프트웨어를 개발하는 방법입니다.
- 객체지향 프로그래밍에서는 데이터와 절차를 하나의 덩어리로 묶어서 생각하게 된다. 이는 마치 컴퓨터 부품을 사다가 컴퓨터를 조립하는 것과 같은 방법입니다.
- 객체지향의 4대 특징은 캡슐화, 상속, 추상화, 다형성으로 아래 '객체지향 프로그래밍(OOP)의 특징'에서 설명하겠습니다.
- 이론적으로만 본다면 객체지향 언어는 절차지향 언어에 비해 장점이 많습니다. 하지만 프로그래밍을 할 때 항상 객체지향 언어만 사용하는 것은 아닙니다.
- 장점
  - 신뢰성 있는 소프트웨어를 쉽게 작성할 수 있음(개발자가 만든 데이터를 사용하기에 신뢰할 수 있습니다.)
  - 코드를 재활용하기 쉽습니다.
  - 업그레이드가 쉽습니다.
  - 디버깅이 쉽습니다.
  - 코딩이 절차지향보다 간편합니다.
- 단점
  - 처리 속도가 절차지향보다 느립니다.
  - 어떤 모듈에 있는 하나의 기능만 필요하더라도 모듈 전체를 가져와야 하기 때문에 절차지향에 비해 프로그램 사이즈가 더 커질 수 있습니다.
  - 데이터에 대한 접근이 절차지향에 비해 느려질 가능성이 큽니다.
  - 메서드를 통해서만 접근이 가능하기 때문에 절차지향처럼 특정 함수에 접근할 수 없고, 식으로만 접근이 가능해 속도적인 측면에서 불이익이 있습니다.



> 객체지향과 절차지향의 차이점

- 객체지향의 반대는 절차지향이 아니고 절차지향의 반대는 객체지향이 아닙니다.

- 위에서 설명한 것처럼 절차지향은 순차적 실행에 초점이 되어 있고, 객체지향은 객체간의 관계/조직에 초점을 두고 있습니다. 이렇게 설명하면 객체지향은 절차적으로 실행되지 않나? 라는 의문이 드는데 객체지향 역시 절차지향과 동일한 순서로 실행됩니다.

  ![객체지향 프로그래밍_1](https://user-images.githubusercontent.com/31823098/112457804-72c8a280-8d9f-11eb-8007-e06114227a21.PNG)

- 절차지향은 데이터를 중심으로 함수를 구현하지만, 객체지향은 기능을 중심으로 메서드를 구현합니다.

- C언어를 사용해도 객체지향적으로 코딩할 수 있습니다. 핵심은 데이터 중심이 아닌 기능 중심으로 구현하는 것입니다.

- 즉, 여러 함수가 데이터를 공유하는 방식이 아니라 특정 함수가 다른 함수를 사용하는 방식으로 구현을 하고, 데이터 공유를 적절히 제한하면 캡슐화 효과를 얻을 수 있습니다.





# 객체지향 프로그래밍(OOP)의 특징



> 상속

- 상속이 없으면 객체지향은 절차지향과 별 다른 바가 없습니다.
- 상위 개념의 특징을 하위 개념이 물려 받는 것입니다.
- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것입니다.
- 하나의 클래스가 가지고 있는 특징(데이터와 함수)들을 그대로 다른 클래스에 물려줄 때 사용합니다.
- 슈퍼 클래스의 속성 및 기능을 하위 클래스가 이어받아 사용할 수 있고, 하위 클래스에서 기능을 변경해야 할 경우 재정의가 가능합니다.
- 보다 적은 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이합니다.
- 이러한 특징은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여합니다.



> 추상화

- 객체들이 가진 공통적인 데이터와 기능을 도출해내는 것입니다.
- ex) 사자, 토끼, 뱀을 동물이라는 추상적인 객체로 추상화
- 추상 클래스
  - 추상 클래스는 미완성 설계도에 비유할 수 있습니다.
  - 추상 클래스는 상속을 통해서 자손 클래스에 의해서만 완성될 수 있습니다.
  - 새로운 클래스를 작성할 때, 아무 것도 없는 상태에서 시작하는 것보다는 완전하지 못하더라도 어느 정도 틀을 갖춘 상태에서 시작하는 것이 나을 것입니다.



> 캡슐화

- 기능과 특성의 모음을 클래스에 캡슐화하는 것입니다.

- 코드를 수정 없이 재사용하기 위해 사용합니다.

- 관련 기능 및 특성을 한 곳에 모으고 분류하여 재사용을 가능하게 합니다.

- 데이터를 외부에서 직접 접근을 못하게 하고 다른 방법(메소드나 프로퍼티 등)을 제공합니다.

  - 어떠한 객체의 명세에 알맞은 기능만을 외부에 노출하도록 합니다.

- 접근 제어자

  ![객체지향 프로그래밍_2](https://user-images.githubusercontent.com/31823098/112457811-752afc80-8d9f-11eb-8ec3-099041502913.PNG)

  - public > protected > default > private
  - 접근 제어자를 사용하는 이유
    - 외부로부터 데이터를 보호하기 위해
    - 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해



> 다형성

- 같은 모양의 코드가 다른 행위를 합니다.
- 동일한 타입을 가진 여러 객체가 같은 속성을 가집니다.
- 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있습니다.
  - ex) 오버로딩, 오버라이딩
  - 오버로딩의 장점
    - 하나의 이름으로 정의함으로써 하나의 이름만 기억하면 되므로 기억하기도 쉽고 같은 기능을 한다는 것을 쉽게 예측할 수 있습니다.
    - 메서드의 이름을 절약할 수 있습니다.
- 상위 클래스 타입에 하위 클래스의 인스턴스를 할당할 수 있습니다.
  - 상속 또는 인터페이스 구현
- 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있습니다.





# 오버로딩 VS 오버라이딩



***Java에서 다형성을 지원하는 방법으로 메서드 오버로딩(Overloading)과 오버라이딩(Overriding)이 있습니다.***



> 오버로딩(Overloading)

- 같은 이름의 메서드를 여러 개 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술
- 오버로딩은 메서드 오버로딩과 생성자 오버로딩이 있습니다. 하지만 둘 다 같은 개념입니다.
- 같은 이름의 메서드를 여러 개 정의하고, 매개변수의 유형과 개수를 다르게 하여 다양한 유형의 호출에 응답하게 합니다.



> 오버라이딩(Overriding)

- 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용합니다.
- 상위 클래스가 가지고 있는 멤버 변수가 하위 클래스로 상속되는 것처럼, 상위 클래스가 가지고 있는 메서드도 하위 클래스로 상속되어 하위 클래스에서 사용될 수 있습니다. 하지만, 하위 클래스에서는 메서드를 재정의하여 사용해야 한다. 이를 오버라이딩이라고 합니다.



> 오버로딩 VS 오버라이딩

![객체지향 프로그래밍_3](https://user-images.githubusercontent.com/31823098/112457822-76f4c000-8d9f-11eb-8ff0-fe055b5cafd3.PNG)





# 클래스 / 객체 / 인스턴스



> 클래스

- 객체를 만들어내기 위한 설계도 혹은 툴
- 연관되어 있는 변수와 메서드의 집합
- 실제 세계의 객체를 추상화하여 그 속성과 행위를 각각 프로퍼티와 메서드로 정의함



> 객체

- 소프트웨어 세계에 구현할 대상
- 클래스에 선언된 모양 그대로 생성된 실체
- '클래스의 인스턴스'라고도 부릅니다.
- 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖습니다.
- OOP의 관점에서 클래스의 타입으로 선언되었을 때, 객체라고 부릅니다.



> 인스턴스

- 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
  - 즉, 객체를 소프트웨어에 실체화하면 그것을 인스턴스라고 부릅니다.
  - 실체화된 인스턴스는 메모리에 할당됩니다.
- 인스턴스는 객체에 포함된다고 볼 수 있습니다.
- OOP의 관점에서 객체가 메모리에 할당되어 실제 사용될 때, 인스턴스라고 부릅니다.
- 인스턴스는 어떤 원본(추상적인 개념)으로부터 생성된 복제본을 의미합니다.



> 클래스 VS 객체 VS 인스턴스

```java
class Animal {
	// 클래스
}
	
public static void main(String[] args) {
	Animal cat;		// 객체 생성
	Animal dog;		// 객체 생성
		
	cat = new Animal();		// 인스턴스 생성
	dog = new Animal();		// 인스턴스 생성
}
```



