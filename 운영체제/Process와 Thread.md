> ## Program



Program이란 파일이 저장 장치에 저장되어 있지만, 메모리에는 올라가 있지 않은 정적인 상태를 말합니다.

이 말을 쉽게 설명해보면,

1. **메모리에 올라가 있지 않은** : 아직 운영체제가 프로그램에게 독립적인 메모리 공간을 할당해주지 않았다는 뜻입니다. 모든 프로그램은 운영체제가 실행되기 위한 메모리 공간을 할당해 주어야 실행될 수 있습니다.
2. **정적인 상태** : '정적'이라는 단어 그대로, 움직이지 않는 상태라는 뜻입니다. 한 마디로 아직 실행되지 않고 가만히 있다는 뜻입니다.

이 프로그램을 실행하는 순간 해당 파일은 컴퓨터 메모리에 올라가게 되고, 이 상태를 동적인 상태라고 하며 이 상태의 프로그램을 `프로세스`라고 합니다. 따라서 대부분의 경우 프로세스에 대해 정의할 때 '실행되고 있는 컴퓨터 프로그램'이라고 정의를 내리고 있으며, 스케줄링 단계에서의 `작업`과 같은 의미로 봐도 무방합니다. 실제로 프로세스라는 단어가 작업중인 프로그램을 의미하는 단어이기 때문입니다.

결론적으로, 프로그램이라는 단어는 아직 실행되지 않은 파일 그 자체를 가리키는 말입니다. 윈도우의 `.exe` 파일이나 MacOS의 `.dmg` 파일 등 사용자가 눌러서 실행하기 전의 파일을 말합니다. 쉽게 말해서 그냥 **`코드 덩어리`** 입니다.





> ## Process



- 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 동적인 개념으로는 실행된 프로그램을 의미



![Process와Thread_1](..\resources\운영체제\Process와Thread_1.PNG)

- **프로세스의 특징**

  - 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받습니다.

  - 기본적으로 프로세스 당 최소 1개의 스레드(메인 스레드)를 가지고 있습니다. (스레드를 추가로 생성하지 않는 한, 모든 프로그램 코드는 메인 스레드에서 실행됩니다.)

  - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없습니다.

  - 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC 등)을 사용해야 합니다.

    ex) 파이프, 파일, 소켓 등을 통한 통신 방법 이용





> ## Thread



- 프로세스 내에서 실행되는 여러 흐름의 단위
- 프로세스의 특정한 수행 경로
- 프로세스가 할당받은 자원을 이용하는 실행의 단위



![Process와Thread_2](..\resources\운영체제\Process와Thread_2.PNG)

- **스레드가 생긴 배경**

  과거에는 프로그램을 실행할 때, 실행 시작부터 실행 끝까지 프로세스 하나만을 사용해서 진행했다고 합니다. 하지만 시간이 흐를수록 프로그램이 복잡해지고 프로세스 하나만을 사용해서 프로그램을 실행하기는 벅차게 되었습니다. 실제로 이제는 프로그램 하나가 단순히 한 가지 작업만을 하는 경우는 없습니다.

  이를 해결하기 위해 쉽게 떠올릴 수 있는 방법은 `한 프로그램을 처리하기 위한 프로세스를 여러 개 만드는 것`이겠지만, 이는 불가능한 일이었습니다. 왜냐하면 운영체제는 안전성을 위해서 프로세스마다 자신에게 할당된 메모리 내의 정보에만 접근할 수 있도록 제약을 두고 있고, 이를 벗어나는 정보에 접근하려면 오류가 발생하기 때문입니다.

  따라서, 프로세스와는 다른 더 작은 실행 단위 개념이 필요하게 되었고, 이 개념이 바로 `스레드`입니다.

  이처럼 스레드는 프로세스 특성의 한계를 해결하기 위해 만들어진 개념이기 때문에 스레드의 특성은 쉽게 유추할 수 있을 것입니다.

- **스레드의 특징**
  
  - 프로그램을 코드 덩어리로 비교하자면, 스레드는 코드 내에 선언된 함수들이 되고 따라서 main 함수 또한 일종의 스레드라고 볼 수 있습니다.
  - 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고, Code, Data, Heap 영역은 공유합니다.
  - 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(Heap 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행됩니다.
  - 같은 프로세스 안에 있는 여러 스레드들은 같은 Heap 공간을 공유합니다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없습니다.
  - 각각의 스레드는 별도의 레지스터와 Stack을 갖고 있지만, Heap 메모리는 서로 읽고 쓸 수 있습니다.
  - 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있습니다.



- **자바 스레드(Java Thread)**
  - 일반 스레드와 거의 차이가 없으며, JVM이 운영체제의 역할을 합니다.
  - 자바에는 프로세스가 존재하지 않고 스레드만 존재하며 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록입니다.
  - 자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어집니다.
  - 아래와 같은 스레드와 관련된 많은 정보들도 JVM이 관리합니다.
    - 스레드가 몇 개 존재하는지
    - 스레드로 실행되는 프로그램 코드의 메모리 위치는 어디인지
    - 스레드의 상태는 무엇인지
    - 스레드 우선순위는 얼마인지
  - 즉, 개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행을 시작하도록 JVM에 요청하는 일을 할 뿐입니다.



> ## Multi Process VS Multi Thread



- Multi Process
  - 멀티 프로세싱이란?
    - 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(Task)을 처리하도록 하는 것입니다.
  - 장점
    - 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않습니다.
  - 단점
    - Context Switching 에서의 오버헤드
      - Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 됩니다.
      - 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching이 발생하면 캐시에 있는 모든 데이터를 모두 리셋하고 다시 캐시 정보를 불러와야 합니다.
    - 프로세스 사이의 어렵고 복잡한 통신 기법(IPC)
      - 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없습니다.
    - Context Switching이란?
      - CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는데 이 과정을 Context Switching 이라고 합니다.
      - 구체적으로, 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말합니다.
- Multi Thread
  - 멀티 스레딩이란?
    - 하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것입니다.
    - 윈도우, 리눅스 등 많은 운영체제들이 멀티 프로세싱을 지원하고 있지만, 멀티 스레딩을 기본으로 하고 있습니다.
    - 웹 서버는 대표적인 멀티 스레드 응용 프로그램입니다.
  - 장점
    - 시스템 자원 소모 감소 (자원의 효율성 증대)
      - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다.
    - 시스템 처리량 증가 (처리 비용 감소)
      - 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 됩니다.
      - 스레드 사이의 작업량이 작아 Context Switching이 빠릅니다.
    - 간단한 통신 방법으로 인한 프로그램 응답 시간 단축
      - 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적습니다.
  - 단점
    - 주의 깊은 설계가 필요합니다.
    - 디버깅이 까다롭습니다.
    - 단일 프로세스 시스템의 경우, 효과를 기대하기 어렵습니다.
    - 다른 프로세스에서 스레드를 제어할 수 없습니다. (즉, 프로세스 밖에서 스레드 각각을 제어할 수 없습니다.)
    - 멀티 스레드의 경우, 자원 공유의 문제가 발생합니다. (동기화 문제)
    - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받습니다.



> ## Multi Process 대신 Multi Thread를 사용하는 이유?



- `Multi Process 대신 Multi Thread를 사용하는 것`의 의미?

  - 쉽게 설명하면, 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것입니다.

    ![Process와Thread_3](..\resources\운영체제\Process와Thread_3.PNG)

- 멀티 프로세스로 할 수 있는 작업들을 하나의 프로세스에서 여러 스레드로 나누어 하는 이유?

  1. 자원의 효율성 증대

     - 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다.

       → 프로세스 간의 Context Switching 시, 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화되므로 오버헤드가 크기 때문입니다.

     - 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 됩니다.

  2. 처리 비용 감소 및 응답 시간 단축

     - 또한, 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적으므로 작업들 간의 통신 부담이 줄어들게 됩니다.

       → 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문입니다.

     - 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠릅니다.

       → Context Switching 시, 스레드는 Stack 영역만 처리하기 때문입니다.

- 주의할 점

  - 동기화 문제
  - 스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 상용할 때, 충돌이 발생할 수 있습니다.





> ## References

- https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html

